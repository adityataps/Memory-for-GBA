#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "gba.h"
#include "game.h"


                    /* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

#include "images/StartScreen.h"
#include "images/a_blank.h"
#include "images/a_dark.h"
#include "images/a_light.h"
#include "images/b_blank.h"
#include "images/b_dark.h"
#include "images/b_light.h"
#include "images/dpad_blank.h"
#include "images/dpad_dark_down.h"
#include "images/dpad_dark_left.h"
#include "images/dpad_dark_right.h"
#include "images/dpad_dark_up.h"
#include "images/dpad_light_down.h"
#include "images/dpad_light_left.h"
#include "images/dpad_light_right.h"
#include "images/dpad_light_up.h"
#include "images/WinScreen.h"
#include "images/LoseScreen.h"
#include "images/gameSpace.h"

#include "test/transparencytest.h"

                    /* TODO: */
// Add any additional states you need for your app.
typedef enum {
    START,
    COMPUTERMOVE,
    PLAYERMOVE,
    WIN,
    LOSE,
} GBAState;

// volatile unsigned short *videoBuffer = (unsigned short *)0x6000000;


void drawFullScreenImage(const u16 *img) {
    // UNUSED_PARAM(img);
    DMA[3].src = img;
    DMA[3].dst = videoBuffer;
    DMA[3].cnt = (DMA_SOURCE_INCREMENT | DMA_DESTINATION_INCREMENT | 240 * 160 | DMA_ON);
    volatile int wait = 0;
    while(wait++ < 10);

}

void drawMove(int move) {
    switch(move) {
        case 0:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_dark_down);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 1:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_dark_left);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 2:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_dark_right);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 3:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_dark_up);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 4:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_blank);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_dark);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 5:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_blank);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_dark);
            break;
        default:
            break;
    }
}

void drawPlayer(int move) {
    switch(move) {
        case 0:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_light_down);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 1:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_light_left);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 2:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_light_right);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 3:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_light_up);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 4:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_blank);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_light);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_blank);
            break;
        case 5:
            waitForVBlank();
            drawImageDMA(20, 50, 100, 100, dpad_blank);
            waitForVBlank();
            drawImageDMA(140, 50, 50, 50, a_blank);
            waitForVBlank();
            drawImageDMA(180, 100, 50, 50, b_light);
            break;
        default:
            break;
    }
}


int main(void) {
                    /* TODO: */
    // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;


    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    // Load initial game state
    GBAState state = START;
    int roundNum = 1;
    volatile int wait = 0;
    int roundCounter = 0;

    while (1) {
        currentButtons = BUTTONS; // Load the current state of the buttons


                    /* TODO: */
        // Manipulate the state machine below as needed //
        // NOTE: Call waitForVBlank() before you draw
        waitForVBlank();

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        }

        switch(state) {
            case START:
                roundNum = 1;
                roundCounter = 0;
                waitForVBlank();
                drawFullScreenImageDMA(StartScreen);

                computerMoves computerMoves;
                computerMoves.size = 10;

                // playerMoves playerMoves;

                int moves[] = {
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                        randint(0, 6),
                };

                computerMoves.moveSeq = moves;

                if (KEY_JUST_PRESSED((BUTTON_A), (currentButtons), (previousButtons))) {
                    state = COMPUTERMOVE;
                    drawFullScreenImageDMA(gameSpace);
                }

                break;
            case COMPUTERMOVE:

                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                    break;
                }

                if (roundNum > 10) {
                    state = WIN;
                    break;
                }
                waitForVBlank();
                drawFullScreenImageDMA(gameSpace);
                waitForVBlank();
                char buffer[128];
                snprintf(buffer,128,"Round %d of 10", roundNum);
                drawString(10, 10, buffer, BLACK);
                waitForVBlank();
                drawString(10, 30, "READY?", BLACK);
                waitForVBlank();
                drawImageDMA(20, 50, 100, 100, dpad_blank);
                waitForVBlank();
                drawImageDMA(140, 50, 50, 50, a_blank);
                waitForVBlank();
                drawImageDMA(180, 100, 50, 50, b_blank);
                wait = 0;
                while(wait++ < 1000000);
                drawFullScreenImage(gameSpace);

                for (int i = 0; i < roundNum; i++) {
                    drawMove(computerMoves.moveSeq[i]);
                    waitForVBlank();
                    drawString(10, 30, "Memorize...", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    wait = 0;

                    while(wait++ < 800000);
                    drawFullScreenImageDMA(gameSpace);
                }

                roundCounter = 0;
                state = PLAYERMOVE;
                break;
            case PLAYERMOVE:
                waitForVBlank();
                char bufferPlayer[128];
                snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                drawString(10, 10, bufferPlayer, BLACK);
                waitForVBlank();
                drawString(10, 30, "Recall!", BLACK);
                waitForVBlank();
                drawImageDMA(20, 50, 100, 100, dpad_blank);
                waitForVBlank();
                drawImageDMA(140, 50, 50, 50, a_blank);
                waitForVBlank();
                drawImageDMA(180, 100, 50, 50, b_blank);

                // int roundCounter = 0;
                bool selectPressed = false;

                if (roundCounter >= roundNum) {
                    state = COMPUTERMOVE;
                    roundNum++;
                    break;
                }
                if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
                    drawPlayer(0);
                    waitForVBlank();
                    drawString(10, 30, "Recall!", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    if (computerMoves.moveSeq[roundCounter] != 0) {
                        state = LOSE;
                        break;
                    } else {
                        roundCounter++;
                    }
                } else if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
                    drawPlayer(1);
                    waitForVBlank();
                    drawString(10, 30, "Recall!", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    if (computerMoves.moveSeq[roundCounter] != 1) {
                        state = LOSE;
                        break;
                    } else {
                        roundCounter++;
                    }
                } else if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
                    drawPlayer(2);
                    waitForVBlank();
                    drawString(10, 30, "Recall!", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    if (computerMoves.moveSeq[roundCounter] != 2) {
                        state = LOSE;
                        break;
                    } else {
                        roundCounter++;
                    }
                } else if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
                    drawPlayer(3);
                    waitForVBlank();
                    drawString(10, 30, "Recall!", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    if (computerMoves.moveSeq[roundCounter] != 3) {
                        state = LOSE;
                        break;
                    } else {
                        roundCounter++;
                    }
                } else if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
                    drawPlayer(4);
                    waitForVBlank();
                    drawString(10, 30, "Recall!", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    if (computerMoves.moveSeq[roundCounter] != 4) {
                        state = LOSE;
                        break;
                    } else {
                        roundCounter++;
                    }
                } else if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
                    drawPlayer(5);
                    waitForVBlank();
                    drawString(10, 30, "Recall!", BLACK);
                    waitForVBlank();
                    char bufferPlayer[128];
                    snprintf(bufferPlayer,128,"Round %d of 10", roundNum);
                    drawString(10, 10, bufferPlayer, BLACK);
                    if (computerMoves.moveSeq[roundCounter] != 5) {
                        state = LOSE;
                        break;
                    } else {
                        roundCounter++;
                    }
                } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    selectPressed = true;
                }

                // }

                // roundCounter++;
                state = PLAYERMOVE;
                if (selectPressed) {
                    state = START;
                }
                break;
            case WIN:
                drawFullScreenImageDMA(WinScreen);
                if (KEY_JUST_PRESSED((BUTTON_A), (currentButtons), (previousButtons))) {
                    state = START;
                    // drawFullScreenImageDMA(gameSpace);
                }
                break;
            case LOSE:
                drawFullScreenImageDMA(LoseScreen);
                roundCounter = 0;
                if (KEY_JUST_PRESSED((BUTTON_A), (currentButtons), (previousButtons))) {
                    state = START;
                    drawFullScreenImageDMA(gameSpace);
                }
                break;
        }



        previousButtons = currentButtons; // Store the current state of the buttons
    }

    UNUSED(previousButtons); // You can remove this once previousButtons is used

    return 0;
}

// void waitForVblank(void) {
//     while(*SCANLINECOUNTER > 160);
//     while(*SCANLINECOUNTER < 160);
// }


